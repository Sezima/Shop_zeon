>>>ImageField<<<

class ImageField ( upload_to = None , height_field = None , width_field = None , max_length = 100 , ** варианты )
Наследует все атрибуты и методы от FileField, но также проверяет, является ли загруженный объект допустимым изображением.

В дополнение к специальным атрибутам, доступным для FileField, он ImageFieldтакже имеет атрибуты heightи .width
Для облегчения запросов к этим атрибутам ImageFieldимеет два дополнительных необязательных аргумента:
Требуется библиотека Pillow .

ImageField экземпляры создаются в вашей базе данных как varchar столбцы с максимальной длиной по умолчанию 100 символов. Как и в случае с другими полями, вы можете изменить максимальную длину с помощью max_lengthаргумента.

>>>>FileField<<<<


класс FileField ( upload_to = '' , storage = None , max_length = 100 , ** варианты )
Поле для загрузки файла.
Аргумент primary_key не поддерживается, и при его использовании возникнет ошибка.

Если вы используете значение по умолчанию FileSystemStorage, строковое значение будет добавлено к вашему MEDIA_ROOTпути, чтобы сформировать местоположение в локальной файловой системе, где будут храниться загруженные файлы. Если вы используете другое хранилище, ознакомьтесь с документацией по этому хранилищу, чтобы узнать, как оно работает upload_to.

upload_to также может быть вызываемым, например функцией.
Это будет вызвано для получения пути загрузки, включая имя файла.
Этот вызываемый объект должен принимать два аргумента и возвращать путь в стиле Unix (с косой чертой), который будет передан системе хранения. Два аргумента: Аргумент	Описание
instance Экземпляр модели, в FileField которой определен . В частности, это конкретный экземпляр, к которому прикрепляется текущий файл.

Виджет формы по умолчанию для этого поля — это файл ClearableFileInput.
В вашем файле настроек вам нужно указать MEDIA_ROOT полный путь к каталогу, в котором вы хотите, чтобы Django хранил загруженные файлы. (Для повышения производительности эти файлы не хранятся в базе данных.)
Определить MEDIA_URLв качестве базового общедоступного URL-адреса этого каталога.
Добавьте FileFieldили ImageFieldв свою модель, определив upload_to возможность указать подкаталог MEDIA_ROOT для использования для загруженных файлов.


Примечание

Файл сохраняется как часть сохранения модели в базе данных, поэтому нельзя полагаться на фактическое имя файла, используемое на диске, до тех пор, пока модель не будет сохранена.
Относительный URL-адрес загруженного файла можно получить с помощью urlатрибута. Внутри это вызывает url()метод базового Storageкласса.
Обратите внимание, что всякий раз, когда вы имеете дело с загруженными файлами, вы должны уделять пристальное внимание тому,
куда вы их загружаете и к какому типу файлов они относятся, чтобы избежать дыр в безопасности. Проверяйте все загруженные файлы , чтобы убедиться, что они именно такие,
как вы думаете. Например, если вы вслепую позволяете кому-то загружать файлы без проверки в каталог, который находится в корневом каталоге документов вашего веб-сервера, тогда кто-то может загрузить сценарий CGI или PHP и выполнить этот сценарий, посетив его URL-адрес на вашем сайте. Не позволяйте этого.
Также обратите внимание, что даже загруженный файл HTML, поскольку он может быть выполнен браузером (но не сервером), может представлять угрозу безопасности, эквивалентную атакам XSS или CSRF.
FileFieldэкземпляры создаются в вашей базе данных как varchar столбцы с максимальной длиной по умолчанию 100 символов. Как и в случае с другими полями, вы можете изменить максимальную длину с помощью max_lengthаргумента.
API FieldFile зеркально отражает API Fileс одним ключевым отличием: объект, обернутый классом, не обязательно является оболочкой вокруг встроенного файлового объекта Python. Вместо этого это оболочка для результата Storage.open() метода, который может быть Fileобъектом или реализацией FileAPI в пользовательском хранилище.

